k1 <- sample(c(1:20), 10, replace = TRUE)
k2 <- sample(c(1:20), 10, replace = TRUE)
k3 <- sample(c(1:20), 10, replace = TRUE)
d12 <- k1 - k2
d13 <- k1 - k3
d23 <- k2 - k3
var(d12)
var(d13)
var(d23)
sqqrt(var(d12))
sqrt(var(d13))
sqrt(var(d12))
sqrt(var(d13))
sqrt(var(d23))
sqrt(var(d12))
sqrt(var(d13))
sqrt(var(d23))
shiny::runApp()
?navbarPage
runApp()
?sliderInput
runApp()
runApp()
?checkboxInput
runApp()
library(shinyjs)
library(shiny)
library(shiny)
library(shinyjs)
runApp()
runApp()
runApp()
ran_inter <- function(n = 240, nklassen = 8, sd_intercept = 10){
stunden <- round(runif(n, 1, 30), digits = 0)
klasse <- sample(1:nklassen, n, replace = TRUE)
effekt <- round(rnorm(nklassen, 0, sd_intercept), digits = 1)
random_intercept <- numeric(n)
for (i in 1:n){
random_intercept[i] <- effekt[klasse[i]]
}
error <- round(rnorm(n, 0, 5), digits = 1)
leistung <- round(20 + 2.5 * stunden + random_intercept + error, digits = 0)
leistung <- ifelse(leistung > 100, 100, leistung)
leistung <- ifelse(leistung < 0, 0, leistung)
klasse <- as.factor(klasse)
levels(klasse) <- paste(1:nklassen, "md", sep = "")
ranint_data <- data.frame(stunden, klasse, leistung)
# writing multilevel model
ri_model <- lmer(leistung ~ stunden + (1|klasse), data = ranint_data)
# saving random variances
var_residual <- attr(VarCorr(ri_model), "sc")^2
var_intercept <- as.numeric(VarCorr(ri_model))
# calculating intraclass correlation
icc <- var_intercept / (var_residual + var_intercept)
# writing lm model
lm_model <- lm(leistung ~ stunden, data = ranint_data)
intercept_lm <- coef(lm_model)[1]
slope_lm <- coef(lm_model)[2]
# plotting data
intercept = coef(ri_model)$klasse[,1]
slope = coef(ri_model)$klasse[,2]
ggplot(data = ranint_data, mapping = aes(x = stunden, y = leistung, color = klasse)) +
geom_point() +
scale_color_viridis_d() +
geom_abline(slope = slope, intercept = intercept, col = viridis(n = nklassen)) +
geom_abline(slope = mean(slope), intercept = mean(intercept), col = "red", size = 1) +
labs(x = "Anzahl Lernstunden", y = "Anzahl Punkte", title = "Erreichte Punktzahl nach Klassen") +
ylim(0,NA)
}
ran_inter(n = 240, nklassen = 8, sd_intercept = 20)
library(lme4)
library(ggplot2)
library(dplyr)
library(tidyr)
library(viridis)
ran_inter <- function(n = 240, nklassen = 8, sd_intercept = 10){
stunden <- round(runif(n, 1, 30), digits = 0)
klasse <- sample(1:nklassen, n, replace = TRUE)
effekt <- round(rnorm(nklassen, 0, sd_intercept), digits = 1)
random_intercept <- numeric(n)
for (i in 1:n){
random_intercept[i] <- effekt[klasse[i]]
}
error <- round(rnorm(n, 0, 5), digits = 1)
leistung <- round(20 + 2.5 * stunden + random_intercept + error, digits = 0)
leistung <- ifelse(leistung > 100, 100, leistung)
leistung <- ifelse(leistung < 0, 0, leistung)
klasse <- as.factor(klasse)
levels(klasse) <- paste(1:nklassen, "md", sep = "")
ranint_data <- data.frame(stunden, klasse, leistung)
# writing multilevel model
ri_model <- lmer(leistung ~ stunden + (1|klasse), data = ranint_data)
# saving random variances
var_residual <- attr(VarCorr(ri_model), "sc")^2
var_intercept <- as.numeric(VarCorr(ri_model))
# calculating intraclass correlation
icc <- var_intercept / (var_residual + var_intercept)
# writing lm model
lm_model <- lm(leistung ~ stunden, data = ranint_data)
intercept_lm <- coef(lm_model)[1]
slope_lm <- coef(lm_model)[2]
# plotting data
intercept = coef(ri_model)$klasse[,1]
slope = coef(ri_model)$klasse[,2]
ggplot(data = ranint_data, mapping = aes(x = stunden, y = leistung, color = klasse)) +
geom_point() +
scale_color_viridis_d() +
geom_abline(slope = slope, intercept = intercept, col = viridis(n = nklassen)) +
geom_abline(slope = mean(slope), intercept = mean(intercept), col = "red", size = 1) +
labs(x = "Anzahl Lernstunden", y = "Anzahl Punkte", title = "Erreichte Punktzahl nach Klassen") +
ylim(0,NA)
}
ran_inter(n = 240, nklassen = 8, sd_intercept = 20)
ran_inter <- function(n = 240, nklassen = 8, sd_intercept = 10){
stunden <- round(runif(n, 1, 30), digits = 0)
klasse <- sample(1:nklassen, n, replace = TRUE)
effekt <- round(rnorm(nklassen, 0, sd_intercept), digits = 1)
random_intercept <- numeric(n)
for (i in 1:n){
random_intercept[i] <- effekt[klasse[i]]
}
error <- round(rnorm(n, 0, 5), digits = 1)
leistung <- round(20 + 2.5 * stunden + random_intercept + error, digits = 0)
# leistung <- ifelse(leistung > 100, 100, leistung)
# leistung <- ifelse(leistung < 0, 0, leistung)
# Als Fussnote erwÃ¤hnen im Beispiel
klasse <- as.factor(klasse)
levels(klasse) <- paste(1:nklassen, "md", sep = "")
ranint_data <- data.frame(stunden, klasse, leistung)
# writing multilevel model
ri_model <- lmer(leistung ~ stunden + (1|klasse), data = ranint_data)
# saving random variances
var_residual <- attr(VarCorr(ri_model), "sc")^2
var_intercept <- as.numeric(VarCorr(ri_model))
# calculating intraclass correlation
icc <- var_intercept / (var_residual + var_intercept)
# writing lm model
lm_model <- lm(leistung ~ stunden, data = ranint_data)
intercept_lm <- coef(lm_model)[1]
slope_lm <- coef(lm_model)[2]
# plotting data
intercept = coef(ri_model)$klasse[,1]
slope = coef(ri_model)$klasse[,2]
print(icc)
ggplot(data = ranint_data, mapping = aes(x = stunden, y = leistung, color = klasse)) +
geom_point() +
scale_color_viridis_d() +
geom_abline(slope = slope, intercept = intercept, col = viridis(n = nklassen)) +
geom_abline(slope = mean(slope), intercept = mean(intercept), col = "red", size = 1) +
labs(x = "Anzahl Lernstunden", y = "Anzahl Punkte", title = "Erreichte Punktzahl nach Klassen") +
ylim(0,NA)
}
ran_inter(n = 240, nklassen = 8, sd_intercept = 20)
ran_inter(n = 240, nklassen = 8, sd_intercept = 10)
ran_inter(n = 240, nklassen = 8, sd_intercept = 4)
ran_inter(n = 240, nklassen = 8, sd_intercept = 1)
ran_inter(n = 240, nklassen = 8, sd_intercept = 2)
ran_inter(n = 240, nklassen = 8, sd_intercept = 1.2)
ran_inter(n = 240, nklassen = 8, sd_intercept = 1.5)
ran_inter(n = 240, nklassen = 8, sd_intercept = 3)
ran_inter <- function(n = 240, nklassen = 8, sd_intercept = 10){
stunden <- round(runif(n, 1, 30), digits = 0)
klasse <- sample(1:nklassen, n, replace = TRUE)
effekt <- round(rnorm(nklassen, 0, sd_intercept), digits = 1)
random_intercept <- numeric(n)
for (i in 1:n){
random_intercept[i] <- effekt[klasse[i]]
}
error <- round(rnorm(n, 0, 5), digits = 1)
leistung <- round(20 + 2.5 * stunden + random_intercept + error, digits = 0)
# leistung <- ifelse(leistung > 100, 100, leistung)
# leistung <- ifelse(leistung < 0, 0, leistung)
# Als Fussnote erwÃ¤hnen im Beispiel
klasse <- as.factor(klasse)
levels(klasse) <- paste(1:nklassen, "md", sep = "")
ranint_data <- data.frame(stunden, klasse, leistung)
# writing multilevel model
ri_model <- lmer(leistung ~ stunden + (1|klasse), data = ranint_data)
# saving random variances
var_residual <- attr(VarCorr(ri_model), "sc")^2
var_intercept <- as.numeric(VarCorr(ri_model))
# calculating intraclass correlation
icc <- var_intercept / (var_residual + var_intercept)
# writing lm model
lm_model <- lm(leistung ~ stunden, data = ranint_data)
intercept_lm <- coef(lm_model)[1]
slope_lm <- coef(lm_model)[2]
# plotting data
intercept = coef(ri_model)$klasse[,1]
slope = coef(ri_model)$klasse[,2]
ggplot(data = ranint_data, mapping = aes(x = stunden, y = leistung, color = klasse)) +
geom_point() +
scale_color_viridis_d() +
geom_abline(slope = slope, intercept = intercept, col = viridis(n = nklassen)) +
geom_abline(slope = mean(slope), intercept = mean(intercept), col = "red", size = 1) +
labs(x = "Anzahl Lernstunden", y = "Anzahl Punkte", title = "Erreichte Punktzahl nach Klassen") +
ylim(0,NA)
}
ran_inter(n = 240, nklassen = 8, sd_intercept = 3)
runApp()
rnorm(8, 0, 0)
rnorm(8, 0, 0)
rnorm(8, 0, 1)
rnorm(8, 0, 0.1)
rnorm(8, 0, 0.000001)
rnorm(8, 0, 0.00
)
rnorm(8, 0, 0)
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
?renderPrint
runApp()
runApp()
runApp()
runApp()
runApp()
?verbatimTextOutput
?fluidrow
?fluidRow
runApp()
?column
runApp()
runApp()
runApp()
runApp()
?hr
?hr()
runApp()
shiny::runApp()
runApp()
random_intercept <- numeric(n)
runApp()
install.packages("MASS")
install.packages("MASS")
library(MASS)
# mas / oder mvt norm paket
cov_matrix <- matrix(c(10,3,3,5), 2, 2)
View(cov_matrix)
mvrnorm(n = 10, mu = 0, Sigma = cov_matrix)
mvrnorm(n = 10, mu = 0, Sigma = cov_matrix)
rep(0,2)
mvrnorm(n = 10, mu = c(0,0), Sigma = cov_matrix)
test <- mvrnorm(n = 10, mu = c(0,0), Sigma = cov_matrix)
test
var(test[,1])
var(test[,2])
test <- mvrnorm(n = 10, mu = c(0,0), Sigma = cov_matrix)
var(test[,1])
var(test[,2])
test <- mvrnorm(n = 10, mu = c(0,0), Sigma = cov_matrix)
var(test[,1])
var(test[,2])
# mas / oder mvt norm paket
cov_matrix <- matrix(c(10,3,3,5), 2, 2)
test <- mvrnorm(n = 10, mu = c(0,0), Sigma = cov_matrix, empirical = TRUE)
var(test[,1])
var(test[,2])
test
test <- mvrnorm(n = 10, mu = c(0,0), Sigma = cov_matrix, empirical = TRUE)
test
test <- mvrnorm(n = 10, mu = c(0,0), Sigma = cov_matrix, empirical = TRUE)
test
var(test[,1])
var(test[,2])
shiny::runApp()
# Generieren des Datensatzes
data_model <- data.frame(matrix(ncol = 3))
ran_inter()
runApp()
?selectizeInput
runApp()
runApp()
runApp()
?switch
runApp()
mean(4)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
slope
runApp()
runApp()
runApp()
?tabsetPanel
runApp()
rnorm(10)
b <- rnomr(10)
b <- rnorm(10)
a <- rnorm(10)
data <- data.frame(a, b)
test <- lm(a ~ b, data = data)
summary(test)
coef(test)
coef(test)[1]
coef(test)[2]
coef(test)[2]+ 1
ggplot(data = data, mapping = aes(x = a, y = b)) +
geom_point() +
geom_abline(intercept = coef(test)[1], slope = coef(test)[2])
runApp()
runApp()

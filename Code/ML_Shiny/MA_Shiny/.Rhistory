k1 <- sample(c(1:20), 10, replace = TRUE)
k2 <- sample(c(1:20), 10, replace = TRUE)
k3 <- sample(c(1:20), 10, replace = TRUE)
d12 <- k1 - k2
d13 <- k1 - k3
d23 <- k2 - k3
var(d12)
var(d13)
var(d23)
sqqrt(var(d12))
sqrt(var(d13))
sqrt(var(d12))
sqrt(var(d13))
sqrt(var(d23))
sqrt(var(d12))
sqrt(var(d13))
sqrt(var(d23))
shiny::runApp()
?navbarPage
runApp()
?sliderInput
runApp()
runApp()
?checkboxInput
runApp()
library(shinyjs)
library(shiny)
library(shiny)
library(shinyjs)
runApp()
runApp()
runApp()
ran_inter <- function(n = 240, nklassen = 8, sd_intercept = 10){
stunden <- round(runif(n, 1, 30), digits = 0)
klasse <- sample(1:nklassen, n, replace = TRUE)
effekt <- round(rnorm(nklassen, 0, sd_intercept), digits = 1)
random_intercept <- numeric(n)
for (i in 1:n){
random_intercept[i] <- effekt[klasse[i]]
}
error <- round(rnorm(n, 0, 5), digits = 1)
leistung <- round(20 + 2.5 * stunden + random_intercept + error, digits = 0)
leistung <- ifelse(leistung > 100, 100, leistung)
leistung <- ifelse(leistung < 0, 0, leistung)
klasse <- as.factor(klasse)
levels(klasse) <- paste(1:nklassen, "md", sep = "")
ranint_data <- data.frame(stunden, klasse, leistung)
# writing multilevel model
ri_model <- lmer(leistung ~ stunden + (1|klasse), data = ranint_data)
# saving random variances
var_residual <- attr(VarCorr(ri_model), "sc")^2
var_intercept <- as.numeric(VarCorr(ri_model))
# calculating intraclass correlation
icc <- var_intercept / (var_residual + var_intercept)
# writing lm model
lm_model <- lm(leistung ~ stunden, data = ranint_data)
intercept_lm <- coef(lm_model)[1]
slope_lm <- coef(lm_model)[2]
# plotting data
intercept = coef(ri_model)$klasse[,1]
slope = coef(ri_model)$klasse[,2]
ggplot(data = ranint_data, mapping = aes(x = stunden, y = leistung, color = klasse)) +
geom_point() +
scale_color_viridis_d() +
geom_abline(slope = slope, intercept = intercept, col = viridis(n = nklassen)) +
geom_abline(slope = mean(slope), intercept = mean(intercept), col = "red", size = 1) +
labs(x = "Anzahl Lernstunden", y = "Anzahl Punkte", title = "Erreichte Punktzahl nach Klassen") +
ylim(0,NA)
}
ran_inter(n = 240, nklassen = 8, sd_intercept = 20)
library(lme4)
library(ggplot2)
library(dplyr)
library(tidyr)
library(viridis)
ran_inter <- function(n = 240, nklassen = 8, sd_intercept = 10){
stunden <- round(runif(n, 1, 30), digits = 0)
klasse <- sample(1:nklassen, n, replace = TRUE)
effekt <- round(rnorm(nklassen, 0, sd_intercept), digits = 1)
random_intercept <- numeric(n)
for (i in 1:n){
random_intercept[i] <- effekt[klasse[i]]
}
error <- round(rnorm(n, 0, 5), digits = 1)
leistung <- round(20 + 2.5 * stunden + random_intercept + error, digits = 0)
leistung <- ifelse(leistung > 100, 100, leistung)
leistung <- ifelse(leistung < 0, 0, leistung)
klasse <- as.factor(klasse)
levels(klasse) <- paste(1:nklassen, "md", sep = "")
ranint_data <- data.frame(stunden, klasse, leistung)
# writing multilevel model
ri_model <- lmer(leistung ~ stunden + (1|klasse), data = ranint_data)
# saving random variances
var_residual <- attr(VarCorr(ri_model), "sc")^2
var_intercept <- as.numeric(VarCorr(ri_model))
# calculating intraclass correlation
icc <- var_intercept / (var_residual + var_intercept)
# writing lm model
lm_model <- lm(leistung ~ stunden, data = ranint_data)
intercept_lm <- coef(lm_model)[1]
slope_lm <- coef(lm_model)[2]
# plotting data
intercept = coef(ri_model)$klasse[,1]
slope = coef(ri_model)$klasse[,2]
ggplot(data = ranint_data, mapping = aes(x = stunden, y = leistung, color = klasse)) +
geom_point() +
scale_color_viridis_d() +
geom_abline(slope = slope, intercept = intercept, col = viridis(n = nklassen)) +
geom_abline(slope = mean(slope), intercept = mean(intercept), col = "red", size = 1) +
labs(x = "Anzahl Lernstunden", y = "Anzahl Punkte", title = "Erreichte Punktzahl nach Klassen") +
ylim(0,NA)
}
ran_inter(n = 240, nklassen = 8, sd_intercept = 20)
ran_inter <- function(n = 240, nklassen = 8, sd_intercept = 10){
stunden <- round(runif(n, 1, 30), digits = 0)
klasse <- sample(1:nklassen, n, replace = TRUE)
effekt <- round(rnorm(nklassen, 0, sd_intercept), digits = 1)
random_intercept <- numeric(n)
for (i in 1:n){
random_intercept[i] <- effekt[klasse[i]]
}
error <- round(rnorm(n, 0, 5), digits = 1)
leistung <- round(20 + 2.5 * stunden + random_intercept + error, digits = 0)
# leistung <- ifelse(leistung > 100, 100, leistung)
# leistung <- ifelse(leistung < 0, 0, leistung)
# Als Fussnote erwÃ¤hnen im Beispiel
klasse <- as.factor(klasse)
levels(klasse) <- paste(1:nklassen, "md", sep = "")
ranint_data <- data.frame(stunden, klasse, leistung)
# writing multilevel model
ri_model <- lmer(leistung ~ stunden + (1|klasse), data = ranint_data)
# saving random variances
var_residual <- attr(VarCorr(ri_model), "sc")^2
var_intercept <- as.numeric(VarCorr(ri_model))
# calculating intraclass correlation
icc <- var_intercept / (var_residual + var_intercept)
# writing lm model
lm_model <- lm(leistung ~ stunden, data = ranint_data)
intercept_lm <- coef(lm_model)[1]
slope_lm <- coef(lm_model)[2]
# plotting data
intercept = coef(ri_model)$klasse[,1]
slope = coef(ri_model)$klasse[,2]
print(icc)
ggplot(data = ranint_data, mapping = aes(x = stunden, y = leistung, color = klasse)) +
geom_point() +
scale_color_viridis_d() +
geom_abline(slope = slope, intercept = intercept, col = viridis(n = nklassen)) +
geom_abline(slope = mean(slope), intercept = mean(intercept), col = "red", size = 1) +
labs(x = "Anzahl Lernstunden", y = "Anzahl Punkte", title = "Erreichte Punktzahl nach Klassen") +
ylim(0,NA)
}
ran_inter(n = 240, nklassen = 8, sd_intercept = 20)
ran_inter(n = 240, nklassen = 8, sd_intercept = 10)
ran_inter(n = 240, nklassen = 8, sd_intercept = 4)
ran_inter(n = 240, nklassen = 8, sd_intercept = 1)
ran_inter(n = 240, nklassen = 8, sd_intercept = 2)
ran_inter(n = 240, nklassen = 8, sd_intercept = 1.2)
ran_inter(n = 240, nklassen = 8, sd_intercept = 1.5)
ran_inter(n = 240, nklassen = 8, sd_intercept = 3)
ran_inter <- function(n = 240, nklassen = 8, sd_intercept = 10){
stunden <- round(runif(n, 1, 30), digits = 0)
klasse <- sample(1:nklassen, n, replace = TRUE)
effekt <- round(rnorm(nklassen, 0, sd_intercept), digits = 1)
random_intercept <- numeric(n)
for (i in 1:n){
random_intercept[i] <- effekt[klasse[i]]
}
error <- round(rnorm(n, 0, 5), digits = 1)
leistung <- round(20 + 2.5 * stunden + random_intercept + error, digits = 0)
# leistung <- ifelse(leistung > 100, 100, leistung)
# leistung <- ifelse(leistung < 0, 0, leistung)
# Als Fussnote erwÃ¤hnen im Beispiel
klasse <- as.factor(klasse)
levels(klasse) <- paste(1:nklassen, "md", sep = "")
ranint_data <- data.frame(stunden, klasse, leistung)
# writing multilevel model
ri_model <- lmer(leistung ~ stunden + (1|klasse), data = ranint_data)
# saving random variances
var_residual <- attr(VarCorr(ri_model), "sc")^2
var_intercept <- as.numeric(VarCorr(ri_model))
# calculating intraclass correlation
icc <- var_intercept / (var_residual + var_intercept)
# writing lm model
lm_model <- lm(leistung ~ stunden, data = ranint_data)
intercept_lm <- coef(lm_model)[1]
slope_lm <- coef(lm_model)[2]
# plotting data
intercept = coef(ri_model)$klasse[,1]
slope = coef(ri_model)$klasse[,2]
ggplot(data = ranint_data, mapping = aes(x = stunden, y = leistung, color = klasse)) +
geom_point() +
scale_color_viridis_d() +
geom_abline(slope = slope, intercept = intercept, col = viridis(n = nklassen)) +
geom_abline(slope = mean(slope), intercept = mean(intercept), col = "red", size = 1) +
labs(x = "Anzahl Lernstunden", y = "Anzahl Punkte", title = "Erreichte Punktzahl nach Klassen") +
ylim(0,NA)
}
ran_inter(n = 240, nklassen = 8, sd_intercept = 3)
runApp()
rnorm(8, 0, 0)
rnorm(8, 0, 0)
rnorm(8, 0, 1)
rnorm(8, 0, 0.1)
rnorm(8, 0, 0.000001)
rnorm(8, 0, 0.00
)
rnorm(8, 0, 0)
runApp()
runApp()
runApp()
runApp()
runApp()

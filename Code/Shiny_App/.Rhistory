asdf <- simulation_study(niter = 1)
str(asdf)
install.packages("apaTables")
power_analyze <- function(x){
y10 = c(0, 0.25, 0.5, 0.75, 1, 1.5)
sd_i = c(0,1,2,3,4,5)
meth = c("lm", "rim")
a <- matrix(ncol = 6, nrow = 6)
b <- matrix(ncol = 6, nrow = 6)
for (m in 1){
for (n in 1:6){
for (i in 1:6){
a[n,i] <- sum(ifelse(x$p_value_likelihood[x$method == meth[m] & x$effect_treatment == y10[i] & x$sd_intercept == sd_i[n]] < 0.05, 1, 0))/
length(x$p_value_likelihood[x$method == meth[m] & x$effect_treatment == y10[i] & x$sd_intercept == sd_i[n]])
}
}
}
for (m in 2){
for (n in 1:6){
for (i in 1:6){
b[n,i] <- sum(ifelse(x$p_value_likelihood[x$method == meth[m] & x$effect_treatment == y10[i] & x$sd_intercept == sd_i[n]] < 0.05, 1, 0))/
length(x$p_value_likelihood[x$method == meth[m] & x$effect_treatment == y10[i] & x$sd_intercept == sd_i[n]])
}
}
}
power <- rbind(a, b)
sd_i2 <- sd_i^2
icc <- sd_i2 / (sd_i2 + 25)
icc <- rep(icc, each = 6, times = 2)
eff <- rep(y10, times = 12)
methods <- rep(meth, each = 36)
pwr <- c()
for (i in 1: 12){
pwr <- append(pwr, power[i,])
}
power_matrix <- matrix(c(pwr, eff, round(icc, digits = 2), methods), ncol = 4, nrow = 72)
power_dataframe <- data.frame(power_matrix)
power_dataframe[,1] <- as.numeric(as.character(power_dataframe[,1]))
colnames(power_dataframe) <- c("power", "effectsize_treatment", "theoretical_icc", "method")
ggplot(data = power_dataframe, mapping = aes(x = theoretical_icc , y = power, group = method)) +
geom_line(aes(color = method)) +
labs(title = "Change in Power / Type-1 Error in varying effects of treatment") +
facet_wrap(~ effectsize_treatment)
return(power_dataframe)
}
power_lvl1 <- power_analyze(test_sim_lvl1)
power_lvl2 <- power_analyze(test_sim_lvl2)
as.table(power_lvl1)
power_lvl1
power_lvl2
power_lvl1
power_lvl2
power_lvl1 <- power_analyze(test_sim_lvl1)
power_lvl2 <- power_analyze(test_sim_lvl2)
power_analyze <- function(x){
y10 = c(0, 0.25, 0.5, 0.75, 1, 1.5)
sd_i = c(0,1,2,3,4,5)
meth = c("lm", "rim")
a <- matrix(ncol = 6, nrow = 6)
b <- matrix(ncol = 6, nrow = 6)
for (m in 1){
for (n in 1:6){
for (i in 1:6){
a[n,i] <- sum(ifelse(x$p_value_likelihood[x$method == meth[m] & x$effect_treatment == y10[i] & x$sd_intercept == sd_i[n]] < 0.05, 1, 0))/
length(x$p_value_likelihood[x$method == meth[m] & x$effect_treatment == y10[i] & x$sd_intercept == sd_i[n]])
}
}
}
for (m in 2){
for (n in 1:6){
for (i in 1:6){
b[n,i] <- sum(ifelse(x$p_value_likelihood[x$method == meth[m] & x$effect_treatment == y10[i] & x$sd_intercept == sd_i[n]] < 0.05, 1, 0))/
length(x$p_value_likelihood[x$method == meth[m] & x$effect_treatment == y10[i] & x$sd_intercept == sd_i[n]])
}
}
}
power <- rbind(a, b)
sd_i2 <- sd_i^2
icc <- sd_i2 / (sd_i2 + 25)
icc <- rep(icc, each = 6, times = 2)
eff <- rep(y10, times = 12)
methods <- rep(meth, each = 36)
pwr <- c()
for (i in 1: 12){
pwr <- append(pwr, power[i,])
}
power_matrix <- matrix(c(pwr, eff, round(icc, digits = 2), methods), ncol = 4, nrow = 72)
power_dataframe <- data.frame(power_matrix)
power_dataframe[,1] <- as.numeric(as.character(power_dataframe[,1]))
colnames(power_dataframe) <- c("power", "effectsize_treatment", "theoretical_icc", "method")
ggplot(data = power_dataframe, mapping = aes(x = theoretical_icc , y = power, group = method)) +
geom_line(aes(color = method)) +
labs(title = "Change in Power / Type-1 Error in varying effects of treatment") +
facet_wrap(~ effectsize_treatment)
}
power_analyze(test_sim_lvl1)
power_analyze(test_sim_lvl2)
sample(c(0:6), n, replace = TRUE)
math_lektionen <- sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
sample(c(0,1), n, replace = TRUE)
# function to analyse data
power_analyze <- function(x){
y10 = c(0, 0.25, 0.5, 0.75, 1, 1.5)
sd_i = c(0,1,2,3,4,5)
meth = c("lm", "rim")
a <- matrix(ncol = 6, nrow = 6)
b <- matrix(ncol = 6, nrow = 6)
for (m in 1){
for (n in 1:6){
for (i in 1:6){
a[n,i] <- sum(ifelse(x$p_value_likelihood[x$method == meth[m] & x$effect_treatment == y10[i] & x$sd_intercept == sd_i[n]] < 0.05, 1, 0))/
length(x$p_value_likelihood[x$method == meth[m] & x$effect_treatment == y10[i] & x$sd_intercept == sd_i[n]])
}
}
}
for (m in 2){
for (n in 1:6){
for (i in 1:6){
b[n,i] <- sum(ifelse(x$p_value_likelihood[x$method == meth[m] & x$effect_treatment == y10[i] & x$sd_intercept == sd_i[n]] < 0.05, 1, 0))/
length(x$p_value_likelihood[x$method == meth[m] & x$effect_treatment == y10[i] & x$sd_intercept == sd_i[n]])
}
}
}
power <- rbind(a, b)
sd_i2 <- sd_i^2
icc <- sd_i2 / (sd_i2 + 25)
icc <- rep(icc, each = 6, times = 2)
eff <- rep(y10, times = 12)
methods <- rep(meth, each = 36)
pwr <- c()
for (i in 1: 12){
pwr <- append(pwr, power[i,])
}
power_matrix <- matrix(c(pwr, eff, round(icc, digits = 2), methods), ncol = 4, nrow = 72)
power_dataframe <- data.frame(power_matrix)
power_dataframe[,1] <- as.numeric(as.character(power_dataframe[,1]))
colnames(power_dataframe) <- c("power", "effectsize_treatment", "theoretical_icc", "method")
ggplot(data = power_dataframe, mapping = aes(x = theoretical_icc , y = power, group = method)) +
geom_line(aes(color = method)) +
labs(title = "Veränderung von Power / Typ-1 Fehler in versch. Einflussstärken eines Treatments") +
facet_wrap(~ effectsize_treatment)
}
power_lvl1 <- power_analyze(test_sim_lvl1)
power_lvl2 <- power_analyze(test_sim_lvl2)
power_lvl1
power_lvl2
test_lvl1 <- simulation_study(niter = 10, sd_intercept = c(0,1,2,3,4,5),
y10 = c(0, 0.25, 0.5, 0.75, 1, 1.5))
power_analyze(test_lvl1)
test_lvl1
View(test_lvl1)
gen_ml_data <- function(n = 15000, nklassen = 300, sd_intercept = 2, sd_slope = 0,
corr = 0, sd_error = 5, y00 = 15, y10 = 0.35){
# Creating Treatment as Level-1 Variable
math_lektionen <- sample(c(0:6), n, replace = TRUE)
klasse <- sample(1:nklassen, n, replace = TRUE)
# Creating Treatment as Level-2 Variable
# anz_math_lektionen <- sample(c(0:6), n, replace = TRUE)
# math_lektionen <- c()
# for (i in 1:n){
#   math_lektionen[i] <- anz_math_lektionen[klasse[i]]
# }
# Creating random effects of klassen
covar01 <- corr * sqrt(sd_intercept^2 * sd_slope^2)
effekte_cov_matrix <- matrix(c(sd_intercept^2,
covar01,
covar01,
sd_slope^2
), 2, 2)
effekte <- mvrnorm(n = nklassen, mu = c(0,0),
Sigma = effekte_cov_matrix, empirical = TRUE)
effekt_int <- effekte[,1]
effekt_slope <- effekte[,2]
# Creating random effects for Intercept and Slope based on klassen
random_intercept <- numeric(n)
for (i in 1:n){
random_intercept[i] <- effekt_int[klasse[i]]
}
random_slope <- numeric(n)
for (i in 1:n){
random_slope[i] <- effekt_slope[klasse[i]]
}
# Creating random error for individuals
error <- rnorm(n, mean = 0, sd = sd_error)
# Calculating individual leistung score
leistung <- y00 +
y10 * math_lektionen +
random_intercept +
random_slope * math_lektionen +
error
# Creating dataframe
klasse <- as.factor(klasse)
levels(klasse) <- paste(1:nklassen, "md", sep = "")
ml_data <- data.frame(klasse, math_lektionen, leistung, random_intercept)
return(ml_data)
}
asdf <- gen_ml_data()
ggplot(data = gen_ml_data, mapping = aes(y = leistung, group = klasse))+
geom_point
ggplot(data = asdf, mapping = aes(y = leistung, group = klasse))+
geom_point
ggplot(data = asdf, mapping = aes(y = leistung, x = math_lektionen, group = klasse))+
geom_point
ggplot(data = asdf, mapping = aes(y = leistung, x = math_lektionen))+
geom_point
ggplot(data = asdf, mapping = aes(y = leistung, x = math_lektionen))+
geom_point()
ggplot(data = asdf, mapping = aes(y = leistung, x = math_lektionen))+
geom_point() +
facet_wrap(~klassen)
ggplot(data = asdf, mapping = aes(y = leistung, x = math_lektionen))+
geom_point() +
facet_wrap(~klasse)
ggplot(data = asdf, mapping = aes(y = leistung, x = math_lektionen))+
geom_point() +
facet_wrap(~klasse[1:5])
ggplot(data = asdf, mapping = aes(y = leistung, x = math_lektionen))+
geom_point() +
facet_wrap(~klasse[1:6])
ggplot(data = asdf, mapping = aes(y = leistung))+
geom_point() +
facet_wrap(~klasse[1:6])
gen_ml_data <- function(n = 15000, nklassen = 300, sd_intercept = 2, sd_slope = 0,
corr = 0, sd_error = 5, y00 = 15, y10 = 0.35){
# Creating Treatment as Level-1 Variable
math_lektionen <- sample(c(0:6), n, replace = TRUE)
klasse <- sample(1:nklassen, n, replace = TRUE)
# Creating Treatment as Level-2 Variable
# anz_math_lektionen <- sample(c(0:6), n, replace = TRUE)
# math_lektionen <- c()
# for (i in 1:n){
#   math_lektionen[i] <- anz_math_lektionen[klasse[i]]
# }
# Creating random effects of klassen
covar01 <- corr * sqrt(sd_intercept^2 * sd_slope^2)
effekte_cov_matrix <- matrix(c(sd_intercept^2,
covar01,
covar01,
sd_slope^2
), 2, 2)
effekte <- mvrnorm(n = nklassen, mu = c(0,0),
Sigma = effekte_cov_matrix, empirical = TRUE)
effekt_int <- effekte[,1]
effekt_slope <- effekte[,2]
# Creating random effects for Intercept and Slope based on klassen
random_intercept <- numeric(n)
for (i in 1:n){
random_intercept[i] <- effekt_int[klasse[i]]
}
random_slope <- numeric(n)
for (i in 1:n){
random_slope[i] <- effekt_slope[klasse[i]]
}
# Creating random error for individuals
error <- rnorm(n, mean = 0, sd = sd_error)
# Calculating individual leistung score
leistung <- y00 +
y10 * math_lektionen +
random_intercept +
random_slope * math_lektionen +
error
# Creating dataframe
klasse <- as.factor(klasse)
levels(klasse) <- paste(1:nklassen, "md", sep = "")
schueler <- c(1:n)
ml_data <- data.frame(klasse, math_lektionen, leistung, random_intercept, schueler)
return(ml_data)
}
asdf <- gen_ml_data()
asdf <- gen_ml_data()
ggplot(data = asdf, mapping = aes(y = leistung, x = schueler))+
geom_point() +
facet_wrap(~klasse[1:6])
asdf
View(asdf)
str(asdf)
asdf[,5] <- as.factor(asdf[,5])
ggplot(data = asdf, mapping = aes(y = leistung, x = schueler))+
geom_point() +
facet_wrap(~klasse[1:6])
gen_ml_data <- function(n = 15000, nklassen = 300, sd_intercept = 2, sd_slope = 0,
corr = 0, sd_error = 5, y00 = 15, y10 = 0.35){
# Creating Treatment as Level-1 Variable
math_lektionen <- sample(c(0:6), n, replace = TRUE)
klasse <- sample(1:nklassen, n, replace = TRUE)
# Creating Treatment as Level-2 Variable
# anz_math_lektionen <- sample(c(0:6), n, replace = TRUE)
# math_lektionen <- c()
# for (i in 1:n){
#   math_lektionen[i] <- anz_math_lektionen[klasse[i]]
# }
# Creating random effects of klassen
covar01 <- corr * sqrt(sd_intercept^2 * sd_slope^2)
effekte_cov_matrix <- matrix(c(sd_intercept^2,
covar01,
covar01,
sd_slope^2
), 2, 2)
effekte <- mvrnorm(n = nklassen, mu = c(0,0),
Sigma = effekte_cov_matrix, empirical = TRUE)
effekt_int <- effekte[,1]
effekt_slope <- effekte[,2]
# Creating random effects for Intercept and Slope based on klassen
random_intercept <- numeric(n)
for (i in 1:n){
random_intercept[i] <- effekt_int[klasse[i]]
}
random_slope <- numeric(n)
for (i in 1:n){
random_slope[i] <- effekt_slope[klasse[i]]
}
# Creating random error for individuals
error <- rnorm(n, mean = 0, sd = sd_error)
# Calculating individual leistung score
leistung <- y00 +
y10 * math_lektionen +
random_intercept +
random_slope * math_lektionen +
error
# Creating dataframe
klasse <- as.factor(klasse)
levels(klasse) <- paste(1:nklassen, "md", sep = "")
ml_data <- data.frame(klasse, math_lektionen, leistung, random_intercept)
return(ml_data)
}
asdf <- gen_ml_data()
ggplot(data = asdf, mapping = aes(y = leistung, x = math_lektionen))+
geom_point() +
facet_wrap(~klasse[1:6])
ggplot(data = asdf, mapping = aes(y = leistung, x = math_lektionen))+
geom_point() +
geom_smooth(method = "lm")+
facet_wrap(~klasse[1:6])
ggplot(data = asdf, mapping = aes(y = leistung, x = math_lektionen))+
geom_point() +
geom_smooth(method = "lm")+
facet_wrap(leistung~klasse[1:6])
ggplot(data = asdf, mapping = aes(y = leistung, x = math_lektionen))+
geom_point() +
geom_smooth(method = "lm")+
facet_wrap(~klasse[1:6])
ggplot(data = asdf, mapping = aes(y = leistung, x = 1:50))+
geom_point() +
geom_smooth(method = "lm")+
facet_wrap(~klasse[1:6])
ggplot(data = asdf, mapping = aes(y = leistung, x = 1:15000))+
geom_point() +
geom_smooth(method = "lm")+
facet_wrap(~klasse[1:6])
View(asdf)
ggplot(data = asdf, mapping = aes(y = leistung, x = math_lektionen, fill = klasse))+
geom_point() +
geom_smooth(method = "lm")+
facet_wrap(~klasse[1:6])
ggplot(data = asdf, mapping = aes(y = leistung, x = math_lektionen, fill = klasse[1:6]))+
geom_point() +
geom_smooth(method = "lm")+
facet_wrap(~klasse[1:6])
ggplot(data = asdf, mapping = aes(y = leistung, x = math_lektionen))+
geom_point() +
geom_smooth(method = "lm")+
facet_wrap(~klasse[1:6])
power_lvl1 <- power_analyze(test_sim_lvl1)
power_lvl2 <- power_analyze(test_sim_lvl2)
power_lvl1
power_lvl2
# loading files
test_sim_lvl1 <- readRDS("test_sim_lvl1")
test_sim_lvl2 <- readRDS("test_sim_lvl2")
# plotting first results
ggplot(data = test_sim_lvl1, mapping = aes(y = p_value_likelihood, x = method, fill = sd_intercept)) +
geom_boxplot()+
facet_wrap(~ effect_treatment)
ggplot(data = test_sim_lvl2, mapping = aes(y = p_value_likelihood, x = method, fill = sd_intercept)) +
geom_boxplot()+
facet_wrap(~ effect_treatment)
# function to analyse data
power_analyze <- function(x){
y10 = c(0, 0.25, 0.5, 0.75, 1, 1.5)
sd_i = c(0,1,2,3,4,5)
meth = c("lm", "rim")
a <- matrix(ncol = 6, nrow = 6)
b <- matrix(ncol = 6, nrow = 6)
for (m in 1){
for (n in 1:6){
for (i in 1:6){
a[n,i] <- sum(ifelse(x$p_value_likelihood[x$method == meth[m] & x$effect_treatment == y10[i] & x$sd_intercept == sd_i[n]] < 0.05, 1, 0))/
length(x$p_value_likelihood[x$method == meth[m] & x$effect_treatment == y10[i] & x$sd_intercept == sd_i[n]])
}
}
}
for (m in 2){
for (n in 1:6){
for (i in 1:6){
b[n,i] <- sum(ifelse(x$p_value_likelihood[x$method == meth[m] & x$effect_treatment == y10[i] & x$sd_intercept == sd_i[n]] < 0.05, 1, 0))/
length(x$p_value_likelihood[x$method == meth[m] & x$effect_treatment == y10[i] & x$sd_intercept == sd_i[n]])
}
}
}
power <- rbind(a, b)
sd_i2 <- sd_i^2
icc <- sd_i2 / (sd_i2 + 25)
icc <- rep(icc, each = 6, times = 2)
eff <- rep(y10, times = 12)
methods <- rep(meth, each = 36)
pwr <- c()
for (i in 1: 12){
pwr <- append(pwr, power[i,])
}
power_matrix <- matrix(c(pwr, eff, round(icc, digits = 2), methods), ncol = 4, nrow = 72)
power_dataframe <- data.frame(power_matrix)
power_dataframe[,1] <- as.numeric(as.character(power_dataframe[,1]))
colnames(power_dataframe) <- c("power", "effectsize_treatment", "theoretical_icc", "method")
ggplot(data = power_dataframe, mapping = aes(x = theoretical_icc , y = power, group = method)) +
geom_line(aes(color = method)) +
labs(title = "Veränderung von Power / Typ-1 Fehler in versch. Einflussstärken eines Treatments") +
facet_wrap(~ effectsize_treatment)
}
power_lvl1 <- power_analyze(test_sim_lvl1)
power_lvl2 <- power_analyze(test_sim_lvl2)
power_lvl1
power_lvl2
library(shiny); runApp('app_dashboard.R')
gen_ml_data <- function(n = 15000, nklassen = 300, sd_intercept = 2, sd_slope = 0,
corr = 0, sd_error = 5, b00 = 15, b10 = 0.35){
# Creating Treatment as Level-1 Variable
math_lektionen <- sample(c(0:6), n, replace = TRUE)
klasse <- sample(1:nklassen, n, replace = TRUE)
# Creating Treatment as Level-2 Variable
# anz_math_lektionen <- sample(c(0:6), n, replace = TRUE)
# math_lektionen <- c()
# for (i in 1:n){
#   math_lektionen[i] <- anz_math_lektionen[klasse[i]]
# }
# Creating random effects of klassen
covar01 <- corr * sqrt(sd_intercept^2 * sd_slope^2)
effekte_cov_matrix <- matrix(c(sd_intercept^2,
covar01,
covar01,
sd_slope^2
), 2, 2)
effekte <- mvrnorm(n = nklassen, mu = c(0,0),
Sigma = effekte_cov_matrix, empirical = TRUE)
effekt_int <- effekte[,1]
effekt_slope <- effekte[,2]
# Creating random effects for Intercept and Slope based on klassen
random_intercept <- numeric(n)
for (i in 1:n){
random_intercept[i] <- effekt_int[klasse[i]]
}
random_slope <- numeric(n)
for (i in 1:n){
random_slope[i] <- effekt_slope[klasse[i]]
}
# Creating random error for individuals
error <- rnorm(n, mean = 0, sd = sd_error)
# Calculating individual leistung score
leistung <- b00 +
b10 * math_lektionen +
random_intercept +
random_slope * math_lektionen +
error
# Creating dataframe
klasse <- as.factor(klasse)
levels(klasse) <- paste(1:nklassen, "md", sep = "")
ml_data <- data.frame(klasse, math_lektionen, leistung, random_intercept, random_slope)
return(ml_data)
}
test <- gen_ml_data()
ml <- lmer(leistung ~ math_lektionen + (1 | klasse), data = test)
summary(ml)
var(test$leistung)
anova(ml)
anova(test)
aov(data = test)
aov(data = test, leistung ~ math_lektionen)
ml <- lmer(leistung ~ 1 + (1 | klasse), data = test)
summary(ml)
ml <- lmer(leistung ~ 1 + (1 | klasse), data = test)
summary(ml)
anova(ml)
summary(anova(ml))
lm <- lm(leistung ~ klassen, data = test)
lm <- lm(leistung ~ klasse, data = test)
anova(lm)
anova(ml)
summary(ml)
